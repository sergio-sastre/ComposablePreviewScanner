package sergio.sastre.composable.preview.scanner.core.scanner

import io.github.classgraph.ClassGraph
import io.github.classgraph.ScanResult
import sergio.sastre.composable.preview.scanner.core.scanner.classpath.Classpath
import sergio.sastre.composable.preview.scanner.core.scanner.previewfinder.PreviewsFinder
import sergio.sastre.composable.preview.scanner.core.scanner.previewfinder.ClasspathPreviewsFinder
import sergio.sastre.composable.preview.scanner.core.scanresult.RequiresLargeHeap
import sergio.sastre.composable.preview.scanner.core.scanresult.filter.ScanResultFilter
import java.io.File
import java.io.InputStream

/**
 * Core Component to scan for Previews
 * @param defaultPackageTreesOfCustomPreviews // TODO
 */
abstract class ComposablePreviewScanner<T>(
    private val findComposableWithPreviewsInClass: ClasspathPreviewsFinder<T>,
    private val defaultPackageTreesOfCustomPreviews: List<String> = listOf("androidx.compose.ui.tooling.preview")
) {

    private var composableWithAnnotationFinder: PreviewsFinder<T> =
        findComposableWithPreviewsInClass

    private var updatedClassGraph = ClassGraph()
        .ignoreMethodVisibility()
        .enableClassInfo()
        .enableMethodInfo()
        .enableAnnotationInfo()
        .enableMemoryMapping()

    /**
     * Scan previews in all packages, including those of external dependencies.
     */
    @RequiresLargeHeap
    fun scanAllPackages(): ScanResultFilter<T> {
        return ScanResultFilter(updatedClassGraph.scan(), composableWithAnnotationFinder)
    }

    /**
     * Scan previews in the given packageTrees
     *
     * @param packageTrees where we want to scan previews
     */
    fun scanPackageTrees(vararg packageTrees: String): ScanResultFilter<T> {
        if (packageTrees.isEmpty()) {
            throw IllegalArgumentException("packages must not be empty. For that, use scanAllPackages() instead")
        }
        updatedClassGraph = updatedClassGraph.acceptPackages(*packageTrees)
        return ScanResultFilter(updatedClassGraph.scan(), composableWithAnnotationFinder)
    }

    /**
     * Scan previews in the given ‘include‘ packageTrees, excluding the 'exclude' packageTrees
     *
     * @param include where we want to scan previews
     * @param exclude where we do not want to scan previews, even though they were inside the included packageTrees
     */
    fun scanPackageTrees(include: List<String>, exclude: List<String>): ScanResultFilter<T> {
        if (include.isEmpty()) {
            throw IllegalArgumentException("include packages must not be empty. For that, use scanAllPackages() instead")
        }
        updatedClassGraph = updatedClassGraph
            .acceptPackages(*include.toTypedArray())
            .rejectPackages(*exclude.toTypedArray())
        return ScanResultFilter(updatedClassGraph.scan(), composableWithAnnotationFinder)
    }

    // TODO -> Replace with list
    fun overrideClasspath(classpath: Classpath) = apply {
        val debugClassesPath = File(classpath.buildDir, classpath.packagePath)
        composableWithAnnotationFinder = findComposableWithPreviewsInClass
            .applyOverridenClasspaths(listOf(classpath.packagePath))
            .applyCustomPreviewPackageTrees(defaultPackageTreesOfCustomPreviews)
        updatedClassGraph.overrideClasspath(debugClassesPath.absolutePath)
    }

    fun overrideClasspath(classpath: String) = apply {
        val currentDir = System.getProperty("user.dir") + "/build"
        overrideClasspath(Classpath(currentDir, classpath))
    }

    /**
     *
     */
    fun overrideClasspath(classpaths: List<Classpath>, packageTreesOfCustomPreviews: List<String>) = apply {
        val debugClassesPaths = classpaths.map { classpath -> File(classpath.buildDir, classpath.packagePath) }
        val absolutePaths = debugClassesPaths.map { it.absolutePath }
        val packagePaths = classpaths.map { it.packagePath }
        composableWithAnnotationFinder = findComposableWithPreviewsInClass
            .applyOverridenClasspaths(packagePaths)
            .applyCustomPreviewPackageTrees(packageTreesOfCustomPreviews + defaultPackageTreesOfCustomPreviews)

        updatedClassGraph.overrideClasspath(absolutePaths)
    }

    /**
     * Scan previews in the given file
     *
     * @param jsonFile a json file that was generated by using ScanResultDump.dumpScanResultToFile(fileName)
     */
    fun scanFile(jsonFile: File): ScanResultFilter<T> {
        val scanResult = ScanResult.fromJSON(jsonFile.bufferedReader().use { it.readLine() })
        return ScanResultFilter(scanResult, composableWithAnnotationFinder)
    }

    /**
     * Scan for previews in the given InputStream.
     *
     * @param inputStream to support accessible by instrumentation tests, like getInstrumentation().context.assets.open(fileName).
     * Such file was generated previously by using ScanResultDump.dumpScanResultToFileInAssets(fileName)
     *
     */
    fun scanFile(inputStream: InputStream): ScanResultFilter<T> {
        val scanResult = ScanResult.fromJSON(inputStream.bufferedReader().use { it.readLine() })
        return ScanResultFilter(scanResult, composableWithAnnotationFinder)
    }
}